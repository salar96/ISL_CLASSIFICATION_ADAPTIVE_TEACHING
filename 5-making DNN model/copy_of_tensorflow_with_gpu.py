# -*- coding: utf-8 -*-
"""Copy of TensorFlow with GPU

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12j_CGRoXKKaFalHavuBNj7JWWvkj5K7i

# Implementing Deep Learning for PSL Hand Gesture Detection

*Salar Basiri - 97200346
Intelligent Systems, Dr. Brushaki
May 2019 *
"""

import tensorflow as tf
device_name = tf.test.gpu_device_name()
if device_name != '/device:GPU:0':
  raise SystemError('GPU device not found')
print('Found GPU at: {}'.format(device_name))

from keras.models import Sequential
from keras.layers import Conv2D, Flatten, Dense, Dropout, MaxPooling2D
from matplotlib import pyplot as plt
import pandas as pd
import numpy as np
from scipy.io import loadmat
#from keras.datasets import mnist

from google.colab import drive
drive.mount('/gdrive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /gdrive/My Drive

import os
 
dirpath = os.getcwd()
print("current directory is : " + dirpath)
foldername = os.path.basename(dirpath)
print("Directory name is : " + foldername)

x = loadmat(r"data10.mat")
#print(x)
xx=x['out']

data=xx;
target=np.zeros(xx.shape[0])
for i in range(0,xx.shape[0]):
    target[i]=xx[i,0,60]

from sklearn.model_selection import train_test_split
x_trn=data[:,:,:-1]
y_trn=target
print(x_trn.shape[0])
x_trn,x_vld,y_trn,y_vld=train_test_split(x_trn,y_trn,test_size=0.08,shuffle=True)
x_trn,x_tst,y_trn,y_tst=train_test_split(x_trn,y_trn,test_size=0.2173555,shuffle=True)
print(x_trn.shape[0],x_vld.shape[0],x_tst.shape[0])

x_trn=x_trn.reshape(x_trn.shape[0],24,60,1)
x_vld=x_vld.reshape(x_vld.shape[0],24,60,1)
x_tst=x_tst.reshape(x_tst.shape[0],24,60,1)

from keras.utils import to_categorical
y_trn=to_categorical(y_trn)
y_vld=to_categorical(y_vld)
y_tst=to_categorical(y_tst)

model=Sequential();
model.add(Conv2D(89,kernel_size=4,activation='relu',input_shape=(24,60,1)))
model.add(MaxPooling2D((3,5),padding='same'))
model.add(Conv2D(89,kernel_size=1,activation='relu'))
model.add(MaxPooling2D((3,5),padding='same'))
model.add(Dropout(0.2))
model.add(Flatten())
model.add(Dense(15,activation='softmax'))
model.summary()

from keras.optimizers import SGD
from keras.callbacks import EarlyStopping,History
opt = SGD(lr=10e-5)
model.compile(optimizer='adam',loss='categorical_crossentropy' , metrics=['accuracy'])
history=History()
cback=EarlyStopping(monitor='val_loss',
                              min_delta=0,
                              patience=15,
                              verbose=0, mode='auto',restore_best_weights=True)

model.load_weights(r"/gdrive/My Drive/Colab Notebooks/final_model_final.HDF5")

h=model.fit(x_trn,y_trn,validation_data=(x_vld,y_vld),epochs=300,shuffle=True,callbacks = [cback,history])

model.save_weights(r"/gdrive/My Drive/weights2.HDF5",overwrite=True)

model.save(r"/gdrive/My Drive/Colab Notebooks/last_model.HDF5")

np.round(model.predict(x_tst)[10,:])

print(y_tst[10])

def give_id(x):
  b=np.zeros(x.shape[0])
  for i in range (0,x.shape[0]):
    for j in range(0,x.shape[1]):
      if np.round(x[i,j])==1:
        b[i]=j;
        
  return b        
  

g=give_id(np.round(model.predict(x_tst)))  
print(g.shape[0],"and",x_tst.shape[0])

final_acc=100-(np.count_nonzero(give_id(np.round(model.predict(x_tst)))-give_id(y_tst))/y_tst.shape[0]*100)
print("reported acc is: " , np.round(final_acc,2),"%")

from sklearn.metrics import confusion_matrix
C=confusion_matrix(give_id(y_tst),give_id(np.round(model.predict(x_tst))))
print(C)

accuracy=np.sum(C.diagonal())/y_tst.shape[0]*100
l=np.random.rand(15,15)
l=C.copy()
ll=l.astype('float')
for i in range(0,15):
  s=sum(l[i,:])
  for j in range(0,15):
    ll[i,j]=np.round(l[i,j]/s*100,2)
print(ll)
print(accuracy)

model.summary()

np.savetxt('last_conf_mat.csv',ll,delimiter=',')

#model.load_weights(r"/gdrive/My Drive/Colab Notebooks/final_model_final.HDF5")
h.history.keys()
#plt.figure(figsize=[6,4],dpi=1200)
plt.plot(h.history['accuracy'],label='Training accuracy',linewidth=2)
plt.plot(h.history['val_accuracy'],label='Validation accuracy',linewidth=2)
#plt.ylim((0,3))
plt.grid()
plt.legend()
plt.title('Training and Validation accuracy diagram')
plt.xlabel('Epoch')
plt.ylabel('Accuracy')
plt.savefig('zzz.eps')
plt.savefig('zzz.svg')

for layer in model.layers:
    
    print(layer.get_output_at(0).get_shape().as_list())